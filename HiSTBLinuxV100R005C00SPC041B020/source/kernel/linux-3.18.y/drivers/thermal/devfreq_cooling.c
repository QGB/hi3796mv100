/*
 * devfreq_cooling: Thermal cooling device implementation for devices using
 *                  devfreq
 *
 * Copyright (C) 2014-2015 ARM Limited
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/devfreq.h>
#include <linux/devfreq_cooling.h>
#include <linux/export.h>
#include <linux/slab.h>
#include <linux/pm_opp.h>
#include <linux/thermal.h>

#include <trace/events/thermal.h>

static DEFINE_MUTEX(devfreq_lock);
static DEFINE_IDR(devfreq_idr);

/**
 * get_idr - function to get a unique id.
 * @idr: struct idr * handle used to create a id.
 * @id: int * value generated by this function.
 *
 * This function will populate @id with an unique
 * id, using the idr API.
 *
 * Return: 0 on success, an error code on failure.
 */
static int get_idr(struct idr *idr, int *id)
{
	int ret;

	mutex_lock(&devfreq_lock);
	ret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);
	mutex_unlock(&devfreq_lock);
	if (unlikely(ret < 0))
		return ret;
	*id = ret;

	return 0;
}

/**
 * release_idr - function to free the unique id.
 * @idr: struct idr * handle used for creating the id.
 * @id: int value representing the unique id.
 */
static void release_idr(struct idr *idr, int id)
{
	mutex_lock(&devfreq_lock);
	idr_remove(idr, id);
	mutex_unlock(&devfreq_lock);
}

static int enable_disable_opps(struct devfreq *df, int max_enabled_state)
{
	int i;
	struct device *dev = df->dev.parent;

	for (i = 0; i < df->profile->max_state; i++) {
		struct dev_pm_opp *opp;
		unsigned int freq = df->profile->freq_table[i];
		bool want_enable = i <= max_enabled_state ? true : false;

		rcu_read_lock();
		opp = dev_pm_opp_find_freq_exact(dev, freq, !want_enable);
		rcu_read_unlock();

		if (PTR_ERR(opp) == -ERANGE)
			continue;
		else if (IS_ERR(opp))
			return PTR_ERR(opp);

		if (want_enable)
			dev_pm_opp_enable(dev, freq);
		else
			dev_pm_opp_disable(dev, freq);
	}

	return 0;
}

static int devfreq_cooling_get_max_state(struct thermal_cooling_device *cdev,
					 unsigned long *state)
{
	struct devfreq_cooling_device *dfc = cdev->devdata;
	struct devfreq *df = dfc->devfreq;

	*state = df->profile->max_state - 1;

	return 0;
}

static int devfreq_cooling_get_cur_state(struct thermal_cooling_device *cdev,
					 unsigned long *state)
{
	struct devfreq_cooling_device *dfc = cdev->devdata;

	*state = dfc->cooling_state;

	return 0;
}

static int devfreq_cooling_set_cur_state(struct thermal_cooling_device *cdev,
					 unsigned long state)
{
	struct devfreq_cooling_device *dfc = cdev->devdata;
	struct devfreq *df = dfc->devfreq;
	struct device *dev = df->dev.parent;
	unsigned long index;
	unsigned long max_state = df->profile->max_state;
	int ret;

	if (state == dfc->cooling_state)
		return 0;

	dev_dbg(dev, "Setting cooling state %lu\n", state);

	if (state >= max_state)
		return -EINVAL;

	index = (max_state - 1) - state;

	ret = enable_disable_opps(df, index);
	if (ret)
		return ret;

	dfc->cooling_state = state;

	return 0;
}

static unsigned long
freq_get_state(struct devfreq *df, unsigned long freq)
{
	unsigned long state = THERMAL_CSTATE_INVALID;
	int i;

	for (i = 0; i < df->profile->max_state; i++) {
		if (df->profile->freq_table[i] == freq)
			state = (df->profile->max_state - 1) - i;
	}

	return state;
}

static unsigned long
state_get_freq(struct devfreq *df, unsigned long state)
{
	unsigned long index = (df->profile->max_state - 1) - state;

	if (index >= df->profile->max_state)
		return 0;

	return df->profile->freq_table[index];
}

static unsigned long
get_static_power(struct devfreq_cooling_device *dfc, unsigned long freq)
{
	struct devfreq *df = dfc->devfreq;
	struct device *dev = df->dev.parent;
	unsigned long voltage;
	struct dev_pm_opp *opp;

	rcu_read_lock();

	opp = dev_pm_opp_find_freq_exact(dev, freq, true);
	if (IS_ERR(opp) && (PTR_ERR(opp) == -ERANGE))
		opp = dev_pm_opp_find_freq_exact(dev, freq, false);

	voltage = dev_pm_opp_get_voltage(opp) / 1000; /* mV */

	rcu_read_unlock();

	if (voltage == 0) {
		dev_warn_ratelimited(dev,
				     "Failed to get voltage for frequency %lu: %ld\n",
				     freq, IS_ERR(opp) ? PTR_ERR(opp) : 0);
		return 0;
	}

	return dfc->power_ops->get_static_power(voltage);
}

static int devfreq_cooling_get_requested_power(struct thermal_cooling_device *cdev,
					       struct thermal_zone_device *tz,
					       u32 *power)
{
	struct devfreq_cooling_device *dfc = cdev->devdata;
	struct devfreq *df = dfc->devfreq;
	struct devfreq_dev_status *status = &df->last_status;
	unsigned long state;
	unsigned long freq = status->current_frequency;
	u32 dyn_power, static_power;

	/* Get dynamic power for state */
	state = freq_get_state(df, freq);
	if (state == THERMAL_CSTATE_INVALID)
		return -EAGAIN;

	dyn_power = dfc->power_table[state];

	/* Scale dynamic power for utilization */
	dyn_power = (dyn_power * status->busy_time) / status->total_time;

	/* Get static power */
	static_power = get_static_power(dfc, freq);

	trace_thermal_power_devfreq_get_power(cdev, status, freq, dyn_power,
					      static_power);

	*power = dyn_power + static_power;

	return 0;
}

static int devfreq_cooling_state2power(struct thermal_cooling_device *cdev,
				       struct thermal_zone_device *tz,
				       unsigned long state,
				       u32 *power)
{
	struct devfreq_cooling_device *dfc = cdev->devdata;
	struct devfreq *df = dfc->devfreq;
	unsigned long freq;
	u32 static_power;

	freq = state_get_freq(df, state);
	static_power = get_static_power(dfc, freq);

	*power = dfc->power_table[state] + static_power;
	return 0;
}

static int devfreq_cooling_power2state(struct thermal_cooling_device *cdev,
				       struct thermal_zone_device *tz,
				       u32 power, unsigned long *state)
{
	struct devfreq_cooling_device *dfc = cdev->devdata;
	struct devfreq *df = dfc->devfreq;
	struct devfreq_dev_status *status = &df->last_status;
	unsigned long freq = status->current_frequency;
	unsigned long busy_time;
	s32 dyn_power;
	u32 static_power;
	int i;

	static_power = get_static_power(dfc, freq);

	dyn_power = power - static_power;
	dyn_power = dyn_power > 0 ? dyn_power : 0;

	/* Scale dynamic power for utilization */
	busy_time = status->busy_time ?: 1;
	dyn_power = (dyn_power * status->total_time) / busy_time;

	/*
	 * Find the first cooling state that is within the power
	 * budget for dynamic power.
	 */
	for (i = 0; i < df->profile->max_state - 1; i++)
		if (dyn_power >= dfc->power_table[i])
			break;

	*state = i;
	trace_thermal_power_devfreq_limit(cdev, freq, *state, power);
	return 0;
}

static struct thermal_cooling_device_ops devfreq_cooling_ops = {
	.get_max_state = devfreq_cooling_get_max_state,
	.get_cur_state = devfreq_cooling_get_cur_state,
	.set_cur_state = devfreq_cooling_set_cur_state,
};

/**
 * devfreq_cooling_gen_power_table(): - Generate power table.
 * @dfc: Pointer to devfreq cooling device.
 *
 * Generate a table with the device's maximum power usage at each cooling
 * state (OPP). The static and dynamic powerm using the appropriate voltage and
 * frequency for the state, is acquired from the struct devfreq_cooling_ops, and
 * summed to make the maximum power draw.
 *
 * The table is malloced, and a pointer put in dfc->power_table. This must be
 * freed when unregistering the devfreq cooling device.
 *
 * Return: 0 on success, negative error code on failure.
 */
static int devfreq_cooling_gen_power_table(struct devfreq_cooling_device *dfc)
{
	struct devfreq *df = dfc->devfreq;
	struct device *dev = df->dev.parent;
	int num_opps;
	struct devfreq_cooling_ops *callbacks = dfc->power_ops;
	unsigned long freq;
	u32 *table;
	int i;

	if (!IS_ENABLED(CONFIG_PM_OPP)) {
		dev_warn(dev, "Can't use power extensions of the devfreq cooling device without CONFIG_PM_OPP\n");
		return -EINVAL;
	}

	rcu_read_lock();
	num_opps = dev_pm_opp_get_opp_count(dev);

	if (num_opps != dfc->devfreq->profile->max_state) {
		rcu_read_unlock();
		return -ERANGE;
	}

	table = devm_kcalloc(dev, num_opps, sizeof(*table), GFP_KERNEL);
	if (!table) {
		rcu_read_unlock();
		return -ENOMEM;
	}

	for (i = 0, freq = ULONG_MAX; i < num_opps; i++, freq--) {
		unsigned long power_dyn, voltage;
		struct dev_pm_opp *opp;

		opp = dev_pm_opp_find_freq_floor(dev, &freq);
		if (IS_ERR(opp))
			break;

		voltage = dev_pm_opp_get_voltage(opp) / 1000; /* mV */

		power_dyn = callbacks->get_dynamic_power(freq, voltage);

		dev_info(dev, "Dynamic power table: %lu MHz @ %lu mV: %lu = %lu mW\n",
			 freq / 1000000, voltage, power_dyn, power_dyn);

		table[i] = power_dyn;
	}
	rcu_read_unlock();

	if (i != num_opps) {
		devm_kfree(dev, table);
		return -EFAULT;
	}

	dfc->power_table = table;

	return 0;
}

/**
 * of_devfreq_cooling_register_power(): - Register devfreq cooling device,
 *                                      with OF and power information.
 * @np: Pointer to OF device_node.
 * @df: Pointer to devfreq device.
 * @ops: Pointer to power ops.
 */
struct devfreq_cooling_device *
of_devfreq_cooling_register_power(struct device_node *np, struct devfreq *df,
				  struct devfreq_cooling_ops *ops)
{
	struct thermal_cooling_device *cdev;
	struct devfreq_cooling_device *dfc;
	struct device *dev = df->dev.parent;
	char dev_name[THERMAL_NAME_LENGTH];
	int err;

	/* freq_table is required to look map state index to frequency. */
	if (!df->profile->max_state || !df->profile->freq_table)
		return ERR_PTR(-EINVAL);

	dfc = devm_kzalloc(dev, sizeof(*dfc), GFP_KERNEL);
	if (!dfc)
		return ERR_PTR(-ENOMEM);

	dfc->devfreq = df;

	if (ops) {
		if (!ops->get_static_power || !ops->get_dynamic_power) {
			err = -EINVAL;
			goto free_dfc;
		}
		dfc->power_ops = ops;

		err = devfreq_cooling_gen_power_table(dfc);
		if (err)
			goto free_dfc;

		devfreq_cooling_ops.get_requested_power =
			devfreq_cooling_get_requested_power;
		devfreq_cooling_ops.state2power = devfreq_cooling_state2power;
		devfreq_cooling_ops.power2state = devfreq_cooling_power2state;
	}

	err = get_idr(&devfreq_idr, &dfc->id);
	if (err)
		goto free_power_table;

	snprintf(dev_name, sizeof(dev_name), "devfreq-%d", dfc->id);

	cdev = thermal_of_cooling_device_register(np, dev_name, dfc,
						  &devfreq_cooling_ops);
	if (IS_ERR(cdev)) {
		err = PTR_ERR(cdev);
		dev_err(df->dev.parent,
			"Failed to register devfreq cooling device (%d)\n",
			err);
		goto release_idr;
	}

	dfc->cdev = cdev;

	return dfc;

release_idr:
	release_idr(&devfreq_idr, dfc->id);
free_power_table:
	if (dfc->power_table)
		devm_kfree(dev, dfc->power_table);
free_dfc:
	devm_kfree(dev, dfc);

	return ERR_PTR(err);
}
EXPORT_SYMBOL(of_devfreq_cooling_register_power);

/**
 * of_devfreq_cooling_register(): - Register devfreq cooling device,
 *                                with OF information.
 * @np: Pointer to OF device_node.
 * @df: Pointer to devfreq device.
 */
struct devfreq_cooling_device *
of_devfreq_cooling_register(struct device_node *np, struct devfreq *df)
{
	return of_devfreq_cooling_register_power(np, df, NULL);
}
EXPORT_SYMBOL(of_devfreq_cooling_register);

/**
 * devfreq_cooling_register(): - Register devfreq cooling device.
 * @df: Pointer to devfreq device.
 */
struct devfreq_cooling_device *devfreq_cooling_register(struct devfreq *df)
{
	return of_devfreq_cooling_register(NULL, df);
}
EXPORT_SYMBOL(devfreq_cooling_register);

/**
 * devfreq_cooling_unregister(): - Unregister devfreq cooling device.
 * @dfc: Pointer to devfreq cooling device to unregister.
 */
void devfreq_cooling_unregister(struct devfreq_cooling_device *dfc)
{
	struct device *dev;

	if (!dfc)
		return;

	dev = dfc->devfreq->dev.parent;

	thermal_cooling_device_unregister(dfc->cdev);

	release_idr(&devfreq_idr, dfc->id);
	if (dfc->power_table)
		devm_kfree(dev, dfc->power_table);
	devm_kfree(dev, dfc);
}
EXPORT_SYMBOL(devfreq_cooling_unregister);
